#!/usr/bin/sed -E -f 

# Remove anything HTML is going to hate us for
s/</\&lt;/g
s/>/\&gt;/g

# Pre-processor
/^#.*/ {
	# We add a span to syntax highlight it
	s/(#.*)/<span class="preproc">\1<\/span>/
	
	# We want to make links out of the headers we have written
	s/#include \"(.*)\"/#include "<a href="\.\/\1tml" alt="\1">\1<\/a>"/
	
	# For pre-processor directives we do no other processing what so ever!
	b
}

# We syntax highlight the standard library stuff (not sure if I want to turn this on)

# s/(std::[^ (]+)/<keyword>\1<\/keyword>/g

# Types
s/(int)/<keyword>\1<\/keyword>/g
s/(char)/<keyword>\1<\/keyword>/g
s/(struct)/<keyword>\1<\/keyword>/g

# Keywords
s/(switch)/<keyword>\1<\/keyword>/g
s/(case)/<keyword>\1<\/keyword>/g
s/(default)/<keyword>\1<\/keyword>/g
s/(new)/<keyword>\1<\/keyword>/g
s/(delete)/<keyword>\1<\/keyword>/g
s/(typedef)/<keyword>\1<\/keyword>/g
s/(return)/<keyword>\1<\/keyword>/g
s/(const)/<keyword>\1<\/keyword>/g
s/(friend)/<keyword>\1<\/keyword>/g

s/(public:)/<keyword>\1<\/keyword>/g
s/(private:)/<keyword>\1<\/keyword>/g
s/(protected:)/<keyword>\1<\/keyword>/g

# This one is special, if we are not careful we also match class= from all the above <span>'s.
s/(class )/<keyword>\1<\/keyword> /g

# Multiline comments
# Issues:
#
# It is valid C/C++ to do this:
#
# /* this is a comment */ myclass = new myclass(); /* comment again */
# this parse has one hell of a greedy regular expression, if you can figure out a way to make it not-greedy, you sir are a god
# back to the issue
# instead of turning that into the following <comment> <code> <comment> it becomes <comment>. Yes, the entire line
# is now a comment. That is bad. So don't use multiple comments on the same line, and you will be fine!


/\/\*/ {
	# Are both the opening and closing quote on the same line? If so, branch to noloop
	/\/\*([^\*][^\/]+)*\*\//b cnoloop
	
	# No, they are apparently not. This means we replace the quote with the correct span tag
	# s/(\/\*.*$)/<comment>\1/
	
	# Label the loop
	: cloop
	
	# Append the next line from the input file to the current line, move cursor forward by one
	N
	
	# Did we find another quote character yet? If not, we branch to label loop
	/\/\*.*\*\//!b cloop
	
	# Label the noloop branch
	: cnoloop
	
	s/(\/\*.*\*\/)/<comment>\1<\/comment>/g
	
	: endcomment

	: cremovetags
	
	s/((\/\*)[^<]+)<keyword>(.*\*\/)/\1\3/g
	s/((\/\*)[^<]+)<\/keyword>(.*\*\/)/\1\3/g
	
	/\/\*[^<]+<keyword>([^\*][^\/]+)*\*\//b cremovetags
	
	# We don't want to process literal strings
	
	b end
}

/\/\/ .*/ {
	s/(\/\/ .*)/<comment>\1<\/comment>/
	
	: cpremovetags

	s/(\/\/ [^<]+)<keyword>(.*)$/\1\2/g
	s/(\/\/ [^<]+)<\/keyword>(.*)$/\1\2/g
	
	/\/\/ [^<]+<keyword>.*$/b cpremovetags
	
	# We don't want to process literal strings
	
	b end
}

# Literal strings, we want to highlight them, but there is a catch
# in C++ we are allowed to start a literal string on one line, and then continue it on the next line
# this means we need to make sure we parse that correctly!

/"/ {
	# Are both the opening and closing quote on the same line? If so, branch to noloop
	/"[^"]*"/b qnoloop
	
	# Label the loop
	: qloop
	
	# Append the next line from the input file to the current line, move cursor forward by one
	N
	
	# Did we find another quote character yet? If not, we branch to label loop
	/"[^"]+"/!b qloop
	
	# Label the noloop branch
	: qnoloop
	
	s/"([^"]*)"/<text>"\1"<\/text>/g
	
	: endquote
	
	# String literals should not contain "syntax" highlighted code. So we remove all keyword tags from them
	# Label removetags
	: qremovetags

	# Remove <keyword> and </keyword> from the source file
	s/("[^<]+)<keyword>([^"]+")/\1\2/g
	s/("[^<]+)<\/keyword>([^"]+")/\1\2/g

	# Check if there are any more keyword tags left in this part of the string literal
	# if so, we branch back to removetags. We basically loop until this condition returns false.
	/"[^"]+<keyword>[^"]+"/b qremovetags
}

: end

s/<([^\/][^>]+)>/<span class="\1">/g
s/<\/[^>]+>/<\/span>/g

: url

# Replace URL's {Text here}[URL here]
s/\{([^\}]*)\}\[([^\[]*)\]/<a href="\2" alt="\1">\1<\/a>/g